Client signs in with Firebase (email/password, Google, etc).

Client gets a Firebase ID token.

Client sends that token to your API /auth/login.

Server verifies token with Firebase Admin SDK, upserts user in your DB, returns your app session (JWT or cookie).

All API routes use middleware to require a verified user.

Client (Vite/React)
// auth.ts
import { getAuth, signInWithEmailAndPassword } from "firebase/auth";

export async function login(email: string, password: string) {
  const auth = getAuth();
  const cred = await signInWithEmailAndPassword(auth, email, password);
  const idToken = await cred.user.getIdToken(); // <-- critical
  const res = await fetch(`${import.meta.env.VITE_API_BASE}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${idToken}` },
    body: JSON.stringify({}),
    credentials: "include",
  });
  if (!res.ok) throw new Error("login failed");
  return res.json(); // your app session payload
}

Server (Express + Admin SDK)
// admin.ts
import admin from "firebase-admin";
admin.initializeApp({
  credential: admin.credential.cert(JSON.parse(process.env.FB_ADMIN_JSON!)),
});
export { admin };

// authMiddleware.ts
import { admin } from "./admin";

export async function verifyFirebase(req, res, next) {
  try {
    const h = req.headers.authorization || "";
    const token = h.startsWith("Bearer ") ? h.slice(7) : null;
    if (!token) return res.status(401).json({ error: "missing token" });
    const decoded = await admin.auth().verifyIdToken(token);
    (req as any).firebaseUser = decoded; // uid, email, etc.
    next();
  } catch (e) {
    res.status(401).json({ error: "invalid token" });
  }
}

// routes/auth.ts  (DB: Firestore or Postgres—example uses Firestore)
import { Router } from "express";
import { admin } from "../admin";
const r = Router();

r.post("/login", async (req, res) => {
  const u = (req as any).firebaseUser; // only present if verifyFirebase used globally
  if (!u) return res.status(401).json({ error: "unauthorized" });

  // Upsert user in DB
  const ref = admin.firestore().collection("users").doc(u.uid);
  await ref.set(
    {
      uid: u.uid,
      email: u.email ?? null,
      displayName: u.name ?? null,
      photoURL: u.picture ?? null,
      provider: u.firebase?.sign_in_provider ?? null,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    },
    { merge: true }
  );

  // Optional: issue your own short-lived JWT or set cookie session
  // res.cookie("session", yourJwt, { httpOnly: true, secure: true, sameSite: "lax" });

  res.json({ ok: true, uid: u.uid });
});

export default r;

// server/index.ts
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { verifyFirebase } from "./authMiddleware";
import authRoutes from "./routes/auth";

const app = express();
app.use(cors({ origin: true, credentials: true }));
app.use(express.json());
app.use(cookieParser());

// Protect everything after this line with Firebase auth
app.use(verifyFirebase);
app.use("/auth", authRoutes);

// Example protected route
app.get("/me", (req, res) => res.json({ uid: (req as any).firebaseUser.uid }));

app.listen(5000);

Firestore security rules (users collection)
// Only the owner reads/writes their own doc
rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    match /users/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }
  }
}

Required config

Client env: VITE_API_BASE, Firebase web config including measurementId optional.

Server env: FB_ADMIN_JSON = full JSON of your service account; enable Firestore.

Firebase console: enable your auth providers. Add your Replit domain under Authentication → Settings → Authorized domains. If using Google sign-in, configure SHA for mobile; for web, domain is enough.