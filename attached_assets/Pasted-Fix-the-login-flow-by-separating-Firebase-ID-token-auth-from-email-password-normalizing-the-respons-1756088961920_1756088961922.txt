Fix the login flow by separating Firebase-ID-token auth from email/password, normalizing the response, and failing fast. Drop “firebaseUid” from the client payload and verify the ID token server-side.

// server/auth/routes.ts
import { Router } from "express";
import { z } from "zod";
import bcrypt from "bcryptjs";
import { auth } from "../firebaseAdmin"; // Admin SDK
import { AuthService } from "../services/authService"; // findByUid/findByEmail/createUser/issueSessionJwt
import type { Request, Response } from "express";

const router = Router();

const EmailLogin = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

router.post("/api/auth/login", async (req: Request, res: Response) => {
  try {
    const authHeader = req.headers.authorization ?? "";

    // Path 1: Firebase login via ID token in Authorization header
    if (authHeader.startsWith("Bearer ")) {
      const idToken = authHeader.slice("Bearer ".length).trim();
      // Verify with Admin SDK
      const decoded = await auth.verifyIdToken(idToken, true);
      const uid = decoded.uid;

      // Upsert user record tied to Firebase UID
      let user = await AuthService.findUserByFirebaseUid(uid);
      if (!user) {
        user = await AuthService.createUser({
          firebaseUid: uid,
          email: decoded.email ?? null,
          emailVerified: !!decoded.email_verified,
          displayName: decoded.name ?? null,
          photoUrl: decoded.picture ?? null,
          provider: decoded.firebase?.sign_in_provider ?? "firebase",
        });
      }

      const sessionJwt = await AuthService.issueSessionJwt({
        userId: user.id,
        strategy: "firebase",
      });

      return res.status(200).json({
        user: sanitizeUser(user),
        tokens: { sessionJwt },
        strategy: "firebase",
      });
    }

    // Path 2: Email/password login (custom auth)
    const parsed = EmailLogin.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid credentials payload" });
    }

    const { email, password } = parsed.data;
    const user = await AuthService.findUserByEmail(email.toLowerCase());
    if (!user || !user.passwordHash) {
      return res.status(401).json({ error: "Invalid email or password" });
    }

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) {
      return res.status(401).json({ error: "Invalid email or password" });
    }

    const sessionJwt = await AuthService.issueSessionJwt({
      userId: user.id,
      strategy: "password",
    });

    return res.status(200).json({
      user: sanitizeUser(user),
      tokens: { sessionJwt },
      strategy: "password",
    });
  } catch (err) {
    return res.status(500).json({ error: "Login failed" });
  }
});

function sanitizeUser(u: any) {
  return {
    id: u.id,
    email: u.email,
    displayName: u.displayName ?? "Skater",
    photoUrl: u.photoUrl ?? null,
    roles: u.roles ?? [],
    createdAt: u.createdAt,
    provider: u.provider ?? "password",
  };
}

export default router;


Client mutations:

Firebase path: call signInWithEmailAndPassword or any Firebase provider, get idToken via getIdToken(), then POST /api/auth/login with Authorization: Bearer <idToken> and empty body.

Password path: POST /api/auth/login with { email, password } JSON. Do not send firebaseUid.

High-leverage checks:

Ensure Admin SDK is initialized with service account on the server only.

Disable the old firebaseUid body param in the client and backend schema.

Standardize response shape { user, tokens.sessionJwt, strategy } so frontend state stays simple.