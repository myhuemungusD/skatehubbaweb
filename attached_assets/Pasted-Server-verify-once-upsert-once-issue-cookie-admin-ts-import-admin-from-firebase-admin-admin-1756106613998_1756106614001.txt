Server: verify once, upsert once, issue cookie
// admin.ts
import admin from "firebase-admin";
admin.initializeApp({ credential: admin.credential.cert(JSON.parse(process.env.FB_ADMIN_JSON!)) });
export { admin };

// routes/auth.ts
import { Router } from "express";
import jwt from "jsonwebtoken";
import { admin } from "../admin";
const r = Router();

r.post("/session", async (req, res) => {
  const h = req.headers.authorization || "";
  const token = h.startsWith("Bearer ") ? h.slice(7) : "";
  const u = await admin.auth().verifyIdToken(token); // throws if invalid

  // Upsert user once
  const ref = admin.firestore().collection("users").doc(u.uid);
  await ref.set({
    uid: u.uid,
    email: u.email ?? null,
    displayName: u.name ?? null,
    photoURL: u.picture ?? null,
    provider: u.firebase?.sign_in_provider ?? null,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
  }, { merge: true });

  // Issue app session cookie (short TTL)
  const appJwt = jwt.sign({ uid: u.uid }, process.env.APP_JWT_SECRET!, { expiresIn: "2h" });
  res.cookie("session", appJwt, { httpOnly: true, sameSite: "lax", secure: true, maxAge: 2*60*60*1000 });
  res.json({ ok: true });
});

export default r;

// middleware/session.ts
import jwt from "jsonwebtoken";
export function requireSession(req, res, next) {
  const tok = req.cookies?.session;
  if (!tok) return res.status(401).json({ error: "no session" });
  try {
    const payload = jwt.verify(tok, process.env.APP_JWT_SECRET!);
    (req as any).uid = (payload as any).uid;
    next();
  } catch { return res.status(401).json({ error: "bad session" }); }
}

// server/index.ts
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import authRoutes from "./routes/auth";
import { requireSession } from "./middleware/session";

const app = express();
app.use(cors({ origin: true, credentials: true }));
app.use(express.json());
app.use(cookieParser());

app.use("/auth", authRoutes);
app.get("/me", requireSession, (req, res) => res.json({ uid: (req as any).uid }));

Cleanup checklist

Remove custom auth routes, DB password hashes, and parallel login code.

Remove localStorage token usage. Use only the HttpOnly cookie.

Keep one “create or update user” on server/session.

Standardize logout: res.clearCookie("session").

Guardrails

Add your Replit and prod domains to Firebase Authorized domains.

Rotate APP_JWT_SECRET.

Firestore rules for /users/{uid} = owner only.

Tests

Unit: token verification happy path and invalid token.

E2E: login → cookie set → /me 200; logout → /me 401.

Frontend: refresh page keeps session via cookie. No token in localStorage.

Adopt this single-path model and the four issues disappear.